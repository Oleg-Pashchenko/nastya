# Лабораторная №3
***
### Вариант №6
#### Выполнила: Литвинова А. М.
***

##### Data structures:
```
статический стек - S
динамическая очередь - F
```

##### Functions to call:
```
3 функции которые нужно вызывать - (P0, P1, P2)
P0 - выполняет задачу T0
P1 - выполняет задачу T1
P2 - выполняет задачу T2
```

##### Logic:
```
1) Поступил запрос -> F (пишем в очередь)
2) В цикле:
2) Если процессор который может выполнить первую задачу из очереди свободен, то выполняем
3) Если процессор занят, то добавляем задачу в стек
4) Та же фигня идет со стеком
Конец цикла
```
***
# Ответы на контрольные вопросы:

## Стек (Stack) в C++

Стек (stack) - это структура данных, которая представляет собой коллекцию элементов, управляемую по принципу "последний вошел, первым вышел" (Last-In, First-Out, LIFO). Это означает, что элемент, добавленный последним, будет удален первым. В C++, стек обычно реализуется с использованием контейнера `std::stack` из стандартной библиотеки.

Пример использования стека в C++:

```cpp
#include <iostream>
#include <stack>

int main() {
    // Создаем пустой стек для хранения целых чисел
    std::stack<int> myStack;

    // Добавляем элементы в стек
    myStack.push(10);
    myStack.push(20);
    myStack.push(30);

    // Вершина стека содержит 30, следующий элемент - 20, затем 10

    // Удаляем элемент с вершины стека
    myStack.pop();

    // Теперь вершина стека содержит 20

    // Получаем значение с вершины стека, но не удаляем его
    int topElement = myStack.top();

    // Выводим значение с вершины стека
    std::cout << "Вершина стека: " << topElement << std::endl;

    // Проверяем, пуст ли стек
    if (myStack.empty()) {
        std::cout << "Стек пуст." << std::endl;
    } else {
        std::cout << "Стек не пуст." << std::endl;
    }

    // Выводим размер стека
    std::cout << "Размер стека: " << myStack.size() << std::endl;

    return 0;
}
```
***
## Назовите основные способы реализации стека. Сравните их.
## Реализация стека

Стек (stack) - это структура данных, управляемая по принципу "последний вошел, первым вышел" (Last-In, First-Out, LIFO). Существует несколько способов реализации стека, и выбор зависит от конкретных требований и ограничений вашего приложения. Ниже приведены основные способы реализации стека и их сравнение:

### 1. Реализация с использованием массива

- **Преимущества**:
    - Простота и эффективность доступа к элементам стека.
    - Минимальное использование памяти для хранения структуры данных.

- **Недостатки**:
    - Ограниченный размер стека, который должен быть определен заранее.
    - В случае переполнения стека может потребоваться динамическое увеличение размера, что может быть затратным.

### 2. Реализация с использованием связанного списка

- **Преимущества**:
    - Динамический размер стека - он может расти или сжиматься по мере необходимости.
    - Нет ограничения на максимальный размер стека.

- **Недостатки**:
    - Больше затрат памяти на хранение дополнительных указателей (указатель на следующий элемент).
    - Может потребоваться больше времени на доступ к элементам по сравнению с массивом.

### 3. Реализация с использованием стандартной библиотеки C++

- **Преимущества**:
    - Удобство и простота в использовании благодаря контейнеру `std::stack`.
    - Встроенная поддержка всех операций стека, таких как `push`, `pop`, `top`.

- **Недостатки**:
    - Использование дополнительных ресурсов стандартной библиотеки, что может повлечь за собой небольшие накладные расходы по сравнению с ручной реализацией.

### Сравнение

- Если вам нужен стек фиксированного размера и вы хотите оптимизировать использование памяти, лучше использовать массив.
- Если вам нужен динамический стек, который может менять размер по мере необходимости, связанный список будет более подходящим выбором.
- Если вам нужна удобная реализация стека с минимумом усилий, вы можете воспользоваться стандартной библиотекой C++ с использованием `std::stack`.

Выбор метода реализации стека зависит от конкретных требований вашего приложения, а также ваших предпочтений по проектированию и использованию структур данных.
```cpp 
#include <iostream>
#include <list>

template <typename T>
class Stack {
public:
    // Помещение элемента на вершину стека
    void push(const T& value) {
        stackList.push_front(value);
    }

    // Удаление элемента с вершины стека
    void pop() {
        if (!empty()) {
            stackList.pop_front();
        }
    }

    // Получение элемента с вершины стека
    T top() const {
        if (!empty()) {
            return stackList.front();
        } else {
            throw std::out_of_range("Стек пуст");
        }
    }

    // Проверка, пуст ли стек
    bool empty() const {
        return stackList.empty();
    }

    // Получение размера стека
    size_t size() const {
        return stackList.size();
    }

private:
    std::list<T> stackList;
};

int main() {
    Stack<int> myStack;

    myStack.push(10);
    myStack.push(20);
    myStack.push(30);

    std::cout << "Вершина стека: " << myStack.top() << std::endl; // Вывод: Вершина стека: 30

    myStack.pop();
    std::cout << "Вершина стека после pop: " << myStack.top() << stdendl; // Вывод: Вершина стека после pop: 20

    std::cout << "Размер стека: " << myStack.size() << std::endl; // Вывод: Размер стека: 2

    return 0;
}

```
***
## Что такое очередь?
Очередь (queue) - это структура данных, которая представляет собой коллекцию элементов, управляемую по принципу "первый вошел, первым вышел" (First-In, First-Out, FIFO). Это означает, что элемент, добавленный первым, будет удален первым. В очереди можно добавлять элементы только в конец (хвост) и удалять элементы только из начала (головы). В C++, очередь обычно реализуется с использованием контейнера std::queue из стандартной библиотеки.

Пример использования очереди в C++:
```cpp
#include <iostream>
#include <queue>

int main() {
    // Создаем пустую очередь для хранения целых чисел
    std::queue<int> myQueue;

    // Добавляем элементы в очередь
    myQueue.push(10);
    myQueue.push(20);
    myQueue.push(30);

    // Удаляем элемент из начала очереди
    myQueue.pop();

    // Получаем значение из начала очереди
    int frontElement = myQueue.front();

    // Выводим значение из начала очереди
    std::cout << "Первый элемент в очереди: " << frontElement << std::endl;

    // Проверяем, пуста ли очередь
    if (myQueue.empty()) {
        std::cout << "Очередь пуста." << std::endl;
    } else {
        std::cout << "Очередь не пуста." << std::endl;
    }

    // Выводим размер очереди
    std::cout << "Размер очереди: " << myQueue.size() << std::endl;

    return 0;
}

```
***
## Назовите основные способы реализации очереди. Сравните их.
### Реализация с использованием массива
##### Преимущества:

- Простота доступа к элементам в начале и конце очереди.
- Эффективность доступа к элементам.
##### Недостатки:

- Фиксированный размер очереди, который должен быть определен заранее.
- В случае переполнения очереди может потребоваться динамическое увеличение размера, что может быть затратным.

### Реализация с использованием связанного списка
##### Преимущества:

- Динамический размер очереди - она может расти или сжиматься по мере необходимости.
- Нет ограничения на максимальный размер очереди.
##### Недостатки:

- Больше затрат памяти на хранение дополнительных указателей (указатели на начало и конец).
- Может потребоваться больше времени на доступ к элементам по сравнению с массивом.
### Реализация с использованием стандартной библиотеки C++
##### Преимущества:

- Удобство и простота в использовании благодаря контейнеру std::queue.
- Встроенная поддержка всех операций очереди, таких как push, pop, front.
##### Недостатки:

- Использование дополнительных ресурсов стандартной библиотеки, что может повлечь за собой небольшие накладные расходы по сравнению с ручной реализацией.
- Выбор метода реализации очереди зависит от конкретных требований вашего приложения. Если вам необходима простая и удобная реализация, то использование стандартной библиотеки C++ может быть наилучшим выбором.
***
## Что такое дек?
Дек (Deque) - это структура данных, которая представляет собой двустороннюю очередь (Double-Ended Queue). Она позволяет добавлять и удалять элементы как с начала (головы), так и с конца (хвоста) структуры данных. Дек объединяет в себе свойства стека (LIFO - Last-In, First-Out) и очереди (FIFO - First-In, First-Out) и предоставляет более широкий спектр операций для манипуляции данными.

### Основные операции с Деком включают:
- push_front(value): Добавление элемента в начало Дека.
- push_back(value): Добавление элемента в конец Дека.
- pop_front(): Удаление элемента с начала Дека.
- pop_back(): Удаление элемента с конца Дека.
- front(): Получение значения элемента с начала Дека, без удаления.
- back(): Получение значения элемента с конца Дека, без удаления.
- empty(): Проверка, пуст ли Дек.
- size(): Получение текущего размера Дека.

Дек является универсальной структурой данных и находит применение в различных задачах, включая обработку очередей и стеков, решение задач связанных с обходом и манипуляциями над данными.

Основное преимущество Дека заключается в его способности эффективно вставлять и удалять элементы как в начало, так и в конец, что делает его мощным инструментом в разнообразных алгоритмах и приложениях.
```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque;

    // Добавляем элементы в начало и конец Дека
    myDeque.push_front(10);  // Добавляем 10 в начало
    myDeque.push_back(20);   // Добавляем 20 в конец
    myDeque.push_back(30);   // Добавляем 30 в конец

    // Выводим содержимое Дека
    std::cout << "Содержимое Дека: ";
    for (const auto& element : myDeque) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // Удаляем элементы с начала и конца Дека
    myDeque.pop_front();  // Удаляем 10 с начала
    myDeque.pop_back();   // Удаляем 30 с конца

    // Выводим обновленное содержимое Дека
    std::cout << "Обновленное содержимое Дека: ";
    for (const auto& element : myDeque) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // Получаем значения элементов с начала и конца Дека
    int frontElement = myDeque.front();
    int backElement = myDeque.back();

    std::cout << "Первый элемент: " << frontElement << std::endl;  // Вывод: Первый элемент: 20
    std::cout << "Последний элемент: " << backElement << std::endl;  // Вывод: Последний элемент: 20

    // Проверяем, пуст ли Дек
    if (myDeque.empty()) {
        std::cout << "Дек пуст." << std::endl;
    } else {
        std::cout << "Дек не пуст." << std::endl;
    }

    // Получаем размер Дека
    size_t dequeSize = myDeque.size();
    std::cout << "Размер Дека: " << dequeSize << std::endl;

    return 0;
}

```
***
## 6) В каких случаях целесообразно применять стек, а каких очередь?
Стек и очередь - это две разные структуры данных, каждая из которых имеет свои собственные применения в зависимости от задачи. Вот несколько примеров, когда целесообразно использовать стек и очередь, а также кодовые примеры для каждой из ситуаций:

### Стек (Stack):
Обратный порядок выполнения операций. Когда вам нужно выполнять операции в обратном порядке (например, при обходе дерева в глубину), стек может быть полезен.
```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> myStack;

    myStack.push(1);
    myStack.push(2);
    myStack.push(3);

    while (!myStack.empty()) {
        int topElement = myStack.top();
        std::cout << topElement << " ";
        myStack.pop();
    }

    // Вывод: 3 2 1
    return 0;
}
```
Отслеживание состояния. Когда вам нужно отслеживать состояние, например, валидацию вложенных символов, стек может быть полезным.
```cpp
#include <iostream>
#include <stack>
#include <string>

bool isBalanced(const std::string& expression) {
    std::stack<char> charStack;

    for (char c : expression) {
        if (c == '(') {
            charStack.push(c);
        } else if (c == ')' && !charStack.empty()) {
            charStack.pop();
        } else if (c == ')' && charStack.empty()) {
            return false;
        }
    }

    return charStack.empty();
}

int main() {
    std::string expression = "(a + (b - c))";

    if (isBalanced(expression)) {
        std::cout << "Скобки сбалансированы." << std::endl;
    } else {
        std::cout << "Скобки не сбалансированы." << std::endl;
    }

    return 0;
}

```
### Очередь (Queue):
Очередь задач. Когда необходимо управлять задачами в порядке их поступления, очередь является подходящей структурой данных.
```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<std::string> taskQueue;

    taskQueue.push("Задача 1");
    taskQueue.push("Задача 2");
    taskQueue.push("Задача 3");

    while (!taskQueue.empty()) {
        std::string currentTask = taskQueue.front();
        std::cout << "Выполняется: " << currentTask << std::endl;
        taskQueue.pop();
    }

    return 0;
}
```
Буферизация данных. Когда данные поступают в неравномерном порядке и их нужно обрабатывать в порядке поступления, очередь может быть полезна
```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> dataQueue;

    dataQueue.push(10);
    dataQueue.push(20);
    dataQueue.push(30);

    while (!dataQueue.empty()) {
        int currentData = dataQueue.front();
        std::cout << "Обработка данных: " << currentData << std::endl;
        dataQueue.pop();
    }

    return 0;
}

```

Стек и очередь - это две разные структуры данных, каждая из которых имеет свои собственные применения в зависимости от задачи. Вот несколько примеров, когда целесообразно использовать стек и очередь, а также кодовые примеры для каждой из ситуаций:

Стек (Stack):
Обратный порядок выполнения операций. Когда вам нужно выполнять операции в обратном порядке (например, при обходе дерева в глубину), стек может быть полезен.
```cpp
#include <iostream>
#include <stack>

int main() {
std::stack<int> myStack;

    myStack.push(1);
    myStack.push(2);
    myStack.push(3);

    while (!myStack.empty()) {
        int topElement = myStack.top();
        std::cout << topElement << " ";
        myStack.pop();
    }

    // Вывод: 3 2 1
    return 0;
}
```
Отслеживание состояния. Когда вам нужно отслеживать состояние, например, валидацию вложенных символов, стек может быть полезным.
```cpp
#include <iostream>
#include <stack>
#include <string>

bool isBalanced(const std::string& expression) {
std::stack<char> charStack;

    for (char c : expression) {
        if (c == '(') {
            charStack.push(c);
        } else if (c == ')' && !charStack.empty()) {
            charStack.pop();
        } else if (c == ')' && charStack.empty()) {
            return false;
        }
    }

    return charStack.empty();
}

int main() {
std::string expression = "(a + (b - c))";

    if (isBalanced(expression)) {
        std::cout << "Скобки сбалансированы." << std::endl;
    } else {
        std::cout << "Скобки не сбалансированы." << std::endl;
    }

    return 0;
}
```
### Очередь (Queue):
Очередь задач. Когда необходимо управлять задачами в порядке их поступления, очередь является подходящей структурой данных.
```cpp
#include <iostream>
#include <queue>

int main() {
std::queue<std::string> taskQueue;

    taskQueue.push("Задача 1");
    taskQueue.push("Задача 2");
    taskQueue.push("Задача 3");

    while (!taskQueue.empty()) {
        std::string currentTask = taskQueue.front();
        std::cout << "Выполняется: " << currentTask << std::endl;
        taskQueue.pop();
    }

    return 0;
}
```
Буферизация данных. Когда данные поступают в неравномерном порядке и их нужно обрабатывать в порядке поступления, очередь может быть полезна.
```cpp
#include <iostream>
#include <queue>

int main() {
std::queue<int> dataQueue;

    dataQueue.push(10);
    dataQueue.push(20);
    dataQueue.push(30);

    while (!dataQueue.empty()) {
        int currentData = dataQueue.front();
        std::cout << "Обработка данных: " << currentData << std::endl;
        dataQueue.pop();
    }

    return 0;
}
```
Коротко говоря, стек и очередь имеют свои собственные области применения в зависимости от задачи. Вам следует выбирать структуру данных в соответствии с требованиями вашей конкретной задачи.
***
## Какие достоинства и недостатки использования статических и динамических структур данных?
Использование статических и динамических структур данных имеет свои достоинства и недостатки, и выбор зависит от конкретной задачи и требований приложения. Вот обзор основных достоинств и недостатков обеих типов структур данных:

### Статические структуры данных:

##### Достоинства:

- Предсказуемость памяти: Статические структуры данных выделяют память на этапе компиляции, что делает их предсказуемыми и эффективными в использовании памяти. Вам не нужно беспокоиться о динамическом выделении или освобождении памяти.

- Производительность: Статические структуры данных могут быть более быстрыми, чем их динамические аналоги, так как они не требуют дополнительных операций выделения и освобождения памяти.

- Простота использования: Статические структуры данных обычно более просты в использовании, поскольку управление памятью происходит автоматически.

##### Недостатки:

- Ограниченный размер: Размер статической структуры данных определяется на этапе компиляции и не может изменяться во время выполнения программы. Это ограничение может привести к проблемам, если размер данных неизвестен заранее.

- Потенциальное переполнение: Использование статических структур данных может привести к переполнению памяти, если количество данных превышает заранее выделенный размер.

### Динамические структуры данных:

##### Достоинства:

- Гибкость: Динамические структуры данных могут изменять размер во время выполнения программы, что делает их более гибкими для работы с данными разной длины.

- Управление памятью: Динамические структуры данных позволяют более эффективно управлять памятью, так как память выделяется и освобождается по мере необходимости.

##### Недостатки:

- Сложность использования: Динамические структуры данных могут быть более сложными в использовании из-за необходимости явного выделения и освобождения памяти. Это может привести к утечкам памяти и ошибкам в управлении ресурсами.

- Накладные расходы: Динамические структуры данных могут иметь накладные расходы на управление памятью, что может ухудшить производительность в некоторых случаях.

- Неопределенность времени выполнения: Использование динамических структур данных может привести к неопределенности времени выполнения (runtime complexity) в отличие от статических структур данных, где время выполнения обычно более предсказуемо.

Итак, выбор между статическими и динамическими структурами данных зависит от требований конкретной задачи. Статические структуры данных подходят для ситуаций, где размер данных известен заранее и не меняется. Динамические структуры данных лучше подходят для ситуаций, где требуется гибкость и эффективное управление памятью, даже при наличии некоторых накладных расходов.
